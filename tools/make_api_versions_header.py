# Copyright (c) 2024 The Chromium Embedded Framework Authors. All rights
# reserved. Use of this source code is governed by a BSD-style license that
# can be found in the LICENSE file.

from __future__ import absolute_import
from cef_parser import get_copyright
from file_util import write_file_if_changed
from version_util import read_version_files
import os
import sys


def make_api_versions_header(json):
  result = get_copyright(full=True, translator=False) + \
"""//
// ---------------------------------------------------------------------------
//
// This file was generated by the make_api_versions_header.py tool. Versions
// are managed using the version_manager.py tool. For usage details see
// https://bitbucket.org/chromiumembedded/cef/wiki/ApiVersioning.md
//

#ifndef CEF_INCLUDE_CEF_API_VERSIONS_H_
#define CEF_INCLUDE_CEF_API_VERSIONS_H_

#include "include/base/cef_build.h"
"""

  for version, hashes in json['hashes'].items():
    version_part = """
// $COMMENT$
#define CEF_API_VERSION_$VER$ $VER$
#define CEF_API_HASH_$VER$_UNIVERSAL "$UNIVERSAL$"
#if defined(OS_WIN)
#define CEF_API_HASH_$VER$_PLATFORM "$WINDOWS$"
#elif defined(OS_MAC)
#define CEF_API_HASH_$VER$_PLATFORM "$MAC$"
#elif defined(OS_LINUX)
#define CEF_API_HASH_$VER$_PLATFORM "$LINUX$"
#endif
""".replace('$VER$', version)

    # Substitute hash values for placeholders.
    for key, value in hashes.items():
      version_part = version_part.replace('$%s$' % key.upper(), value)

    result += version_part

  result += \
"""
// Oldest supported CEF version.
#define CEF_API_VERSION_MIN CEF_API_VERSION_$MIN$

// Newest supported CEF version.
#define CEF_API_VERSION_LAST CEF_API_VERSION_$LAST$

#endif  // CEF_INCLUDE_CEF_API_VERSIONS_H_
""".replace('$LAST$', json['last']).replace('$MIN$', json['min'])

  return result


def make_api_versions_inc(json):
  result = get_copyright(full=False, translator=False) + \
"""//
// ---------------------------------------------------------------------------
//
// This file was generated by the make_api_versions_header.py tool.
//

namespace {

struct ApiVersionHash {
  int version;
  const char* const universal;
  const char* const platform;
};

const ApiVersionHash kApiVersionHashes[] = {"""

  for version, hashes in json['hashes'].items():
    result += """
  {$VER$, CEF_API_HASH_$VER$_UNIVERSAL, CEF_API_HASH_$VER$_PLATFORM},""".replace(
        '$VER$', version)

  result += \
"""
};

const size_t kApiVersionHashesSize = std::size(kApiVersionHashes);

}  // namespace
"""

  return result


def write_api_versions(out_header_file, out_inc_file, json):
  out_file = os.path.abspath(out_header_file)
  result = make_api_versions_header(json)
  if not bool(result):
    sys.stderr.write('Failed to create %s\n' % out_file)
    sys.exit(1)
  retval1 = write_file_if_changed(out_file, result)

  out_file = os.path.abspath(out_inc_file)
  result = make_api_versions_inc(json)
  if not bool(result):
    sys.stderr.write('Failed to create %s\n' % out_file)
    sys.exit(1)
  retval2 = write_file_if_changed(out_file, result)

  return retval1 or retval2


def main(argv):
  if len(argv) < 5:
    print(
        "Usage:\n  %s <output_header_file> <output_inc_file> <api_versions_file> <api_untracked_file>"
        % argv[0])
    sys.exit(-1)

  json, initialized = \
      read_version_files(argv[3], argv[4], True, combine=True)
  if not write_api_versions(argv[1], argv[2], json):
    print('Nothing done')


if '__main__' == __name__:
  main(sys.argv)
